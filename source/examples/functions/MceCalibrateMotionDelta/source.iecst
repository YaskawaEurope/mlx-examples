// -----------------------------------------------------------------------------
// init
// -----------------------------------------------------------------------------
io.bError := FALSE;

fbGetProperties.Enable := FALSE;
fbSetProperties.Enable := FALSE;
fbMovePtp.Enable := FALSE;

MEMUtils.MemSet(
pbyBuffer := ADR(stJogAxis.aDirections),
byValue := 0,
dwSize := SIZEOF(stJogAxis.aDirections));

MEMUtils.MemSet(
pbyBuffer := ADR(stJogAxis.aDelta),
byValue := 0,
dwSize := SIZEOF(stJogAxis.aDelta));

MEMUtils.MemSet(
pbyBuffer := ADR(stJogTcp.aDirections),
byValue := 0,
dwSize := SIZEOF(stJogTcp.aDirections));

MEMUtils.MemSet(
pbyBuffer := ADR(stJogTcp.aDelta),
byValue := 0,
dwSize := SIZEOF(stJogTcp.aDelta));

MEMUtils.MemSet(
pbyBuffer := ADR(fbMovePtp.TargetPosition),
byValue := 0,
dwSize := SIZEOF(fbMovePtp.TargetPosition));

io.fActualSpeed := 0;

// -----------------------------------------------------------------------------
// common
// -----------------------------------------------------------------------------
IF stJogAxis.bOsrSegmentDone OR stJogTcp.bOsrSegmentDone THEN
  nMotions := nMotions + 1;
END_IF;


// -----------------------------------------------------------------------------
// state machine 1: calibration
// -----------------------------------------------------------------------------
CASE io.nSmCalibration OF
  // -------------------------------------
  // idle, not ready for start
  // -------------------------------------
  0:
    IF io.bSystemReady THEN
      io.nErrorCode := 0;
      io.nSmCalibration := 10;
    END_IF;

  // -------------------------------------
  // ready for calibration
  // -------------------------------------
  10:
    nRobotNumberSelected := io.nRobotNumber;

    IF io.bCalibrate THEN
      nCalibrationType := io.nCalibrationType;
      io.nDelta := 0;
      io.nMeasurement := 0;
      io.nSmCalibration := 11;
    END_IF;

  // -------------------------------------
  // get properties
  // -------------------------------------
  11:
    fbGetProperties.Enable := TRUE;
    IF fbGetProperties.Sts_EN AND fbGetProperties.Sts_DN THEN
      IF fbGetProperties.Sts_ER THEN
        io.nErrorCode := 1000 + io.nSmCalibration;
        io.nSmCalibration := 99;
      ELSE
        io.nSmCalibration := 12;
      END_IF;
    END_IF;

  // -------------------------------------
  // set properties
  // -------------------------------------
  12:
    FOR i := 0 TO 5 DO
      MLX.Robot[nRobotNumberSelected].RobotAxes[i].ConfigurationData.FeedbackUserDataType := 4;
    END_FOR;

    fbSetProperties.Enable := TRUE;
    IF fbSetProperties.Sts_EN AND fbSetProperties.Sts_DN THEN
      IF fbSetProperties.Sts_ER THEN
        io.nErrorCode := 1000 + io.nSmCalibration;
        io.nSmCalibration := 99;
      ELSE
        io.nSmCalibration := 13;
      END_IF;
    END_IF;

  // -------------------------------------
  // select tool
  // -------------------------------------
  13:
    // init
    MEMUtils.MemSet(
    pbyBuffer := ADR(fbSelectTool.ToolData),
    byValue := 0,
    dwSize := SIZEOF(fbSelectTool.ToolData));

    fbSelectTool.RobotNumber := io.nRobotNumber;
    fbSelectTool.ToolNumber := 0;
    fbSelectTool.Enable := TRUE;
    IF fbSelectTool.Sts_EN AND fbSelectTool.Sts_DN THEN
      IF fbSelectTool.Sts_ER THEN
        io.nErrorCode := 1000 + io.nSmCalibration;
        io.nSmCalibration := 99;
      ELSE
        CASE nCalibrationType OF
           CALIBTYPE_AXIS:
            io.nSmCalibration := 20;
           CALIBTYPE_TCP:
            io.nSmCalibration := 30;
        END_CASE;
      END_IF;
    END_IF;

  // -------------------------------------
  // init (axis)
  // -------------------------------------
  20:
   CASE io.nMeasurement OF
     MEAS_LO:
      fSpeed := io.stMotionDeltas.stAxis.fSpeedLo;

     MEAS_HI:
      fSpeed := io.stMotionDeltas.stAxis.fSpeedHi;
   END_CASE;

    bReverse := FALSE;
    // initial delta
    io.nDelta := 1;

    fbMovePtp.Enable := TRUE;

    IF fbMovePtp.Sts_EN AND fbMovePtp.Sts_DN THEN
      IF fbMovePtp.Sts_ER THEN
        io.nErrorCode := 1000 + io.nSmCalibration;
        io.nSmCalibration := 99;
      END_IF;

      IF fbMovePtp.Sts_PC THEN
        io.nSmCalibration := 21;
      END_IF;
    END_IF;

  // -------------------------------------
  // prepare axis motion
  // -------------------------------------
  21:
    nMotions := 0;
    fSpeedMin := fSpeed;
    fSpeedMax := 0;

    io.nSmCalibration := 22;

  // -------------------------------------
  // jog axis
  // -------------------------------------
  22:
    IF bReverse THEN
      stJogAxis.aDirections[io.nAxis] := -1;
    ELSE
      stJogAxis.aDirections[io.nAxis] := 1;
    END_IF;

    IF (nMotions >= NR_OF_MOTIONS) THEN
      io.nSmCalibration := 23;
    END_IF;

  // -------------------------------------
  // jog axis - coasting
  // -------------------------------------
  23:
    IF stJogAxis.bDone OR stJogAxis.bIdle THEN
      io.nSmCalibration := 24;
    END_IF;

  // -------------------------------------
  // verify results (axis)
  // -------------------------------------
  24:
    // measured speed
    CASE io.nMeasurement OF
      MEAS_LO:
        // use max speed
        fSpeedMeasured := (fSpeedMax / fSpeed) * 100;

      MEAS_HI:
        // use min speed
        fSpeedMeasured := (fSpeedMin / fSpeed) * 100;
    END_CASE;

    IF (fSpeedMeasured < 97) THEN
      // increase the delta and change direction
      CASE io.nMeasurement OF
        MEAS_HI:
          // coarse/fine steps
          IF (fSpeedMeasured < 90) THEN
            io.nDelta := io.nDelta + 10;
          ELSE
            io.nDelta := io.nDelta + 1;
          END_IF;

        ELSE
          io.nDelta := io.nDelta + 1;
      END_CASE;
      bReverse := NOT bReverse;
      io.nSmCalibration := 21;

    ELSE
      // store result and proceed
      CASE io.nMeasurement OF
        MEAS_LO:
          io.stMotionDeltas.stAxis.aDeltaLo[io.nAxis] :=
            UINT_TO_REAL(io.nDelta) / 10;
          io.nMeasurement := io.nMeasurement + 1;
          io.nSmCalibration := 20;

        MEAS_HI:
          io.stMotionDeltas.stAxis.aDeltaHi[io.nAxis] :=
            UINT_TO_REAL(io.nDelta) / 10;
          io.nSmCalibration := 40;
      END_CASE;
    END_IF;

    IF NOT io.bCalibrate THEN
      io.nSmCalibration := 21;
    END_IF;

  // -------------------------------------
  // init (TCP)
  // -------------------------------------
  30:
   CASE io.nMeasurement OF
     MEAS_LO:
      fSpeed := io.stMotionDeltas.stTcp.fSpeedLo;

     MEAS_HI:
      fSpeed := io.stMotionDeltas.stTcp.fSpeedHi;
   END_CASE;

    bReverse := FALSE;
    // initial delta
    io.nDelta := 1;

//     fbMovePtp.TargetPosition.AxisPosition[4] := -90;
    fbMovePtp.Enable := TRUE;

    IF fbMovePtp.Sts_EN AND fbMovePtp.Sts_DN THEN
      IF fbMovePtp.Sts_ER THEN
        io.nErrorCode := 1000 + io.nSmCalibration;
        io.nSmCalibration := 99;
      END_IF;

      IF fbMovePtp.Sts_PC THEN
        io.nSmCalibration := 31;
      END_IF;
    END_IF;

  // -------------------------------------
  // prepare TCP motion
  // -------------------------------------
  31:
    nMotions := 0;
    fSpeedMin := fSpeed;
    fSpeedMax := 0;

    io.nSmCalibration := 32;

  // -------------------------------------
  // jog TCP
  // -------------------------------------
  32:
    IF bReverse THEN
      stJogTcp.aDirections[io.nAxis] := -1;
    ELSE
      stJogTcp.aDirections[io.nAxis] := 1;
    END_IF;

    IF (nMotions >= NR_OF_MOTIONS) THEN
      io.nSmCalibration := 33;
    END_IF;

  // -------------------------------------
  // jog TCP - coasting
  // -------------------------------------
  33:
    IF stJogTcp.bDone OR stJogTcp.bIdle THEN
      io.nSmCalibration := 34;
    END_IF;

  // -------------------------------------
  // verify results (TCP)
  // -------------------------------------
  34:
    // measured speed
    CASE io.nMeasurement OF
      MEAS_LO:
        // use max speed
        fSpeedMeasured := (fSpeedMax / fSpeed) * 100;

      MEAS_HI:
        // use min speed
        fSpeedMeasured := (fSpeedMin / fSpeed) * 100;
    END_CASE;

    IF (fSpeedMeasured < 99) THEN
      // increase the delta and change direction
      CASE io.nMeasurement OF
        MEAS_HI:
          // coarse/fine steps
          IF (fSpeedMeasured < 95) THEN
            io.nDelta := io.nDelta + 30;
          ELSE
            io.nDelta := io.nDelta + 3;
          END_IF;

        ELSE
          io.nDelta := io.nDelta + 1;
      END_CASE;
      bReverse := NOT bReverse;
      io.nSmCalibration := 31;

    ELSE
      // store result and proceed
      CASE io.nMeasurement OF
        MEAS_LO:
          io.stMotionDeltas.stTcp.aDeltaLo[io.nAxis] :=
            UINT_TO_REAL(io.nDelta) / 10;
          io.nMeasurement := io.nMeasurement + 1;
          io.nSmCalibration := 30;

        MEAS_HI:
          io.stMotionDeltas.stTcp.aDeltaHi[io.nAxis] :=
            UINT_TO_REAL(io.nDelta) / 10;
          io.nSmCalibration := 40;
      END_CASE;
    END_IF;

    IF NOT io.bCalibrate THEN
      io.nSmCalibration := 31;
    END_IF;

  // -------------------------------------
  // done
  // -------------------------------------
  40:
    IF NOT io.bCalibrate THEN
      io.nSmCalibration := 0;
    END_IF;

  // -------------------------------------
  // state machine error
  // -------------------------------------
  99:
    io.bError := TRUE;
    IF NOT io.bCalibrate THEN
      io.nSmCalibration := 0;
    END_IF;

  ELSE
    io.nSmCalibration := 0;
END_CASE;


// -----------------------------------------------------------------------------
// reset
// -----------------------------------------------------------------------------
IF NOT io.bsystemReady THEN
  io.nSmCalibration := 0;
END_IF;


// -----------------------------------------------------------------------------
// outputs
// -----------------------------------------------------------------------------
io.bIdle := (io.nSmCalibration = 0);
io.bDone := (io.nSmCalibration = 40);
io.bJogBusy :=
  (io.nSmCalibration = 22) OR
  (io.nSmCalibration = 23) OR
  (io.nSmCalibration = 32) OR
  (io.nSmCalibration = 33);
io.bCoasting := (io.nSmCalibration = 23) OR (io.nSmCalibration = 33);
bMeasuring := io.bJogBusy AND NOT io.bCoasting AND (nMotions >= 2);


// -----------------------------------------------------------------------------
// scale actual speed
// -----------------------------------------------------------------------------
IF io.bJogBusy THEN
  CASE nCalibrationType OF
    CALIBTYPE_AXIS:
      io.fActualSpeed :=
        100 *
        ABS(
        MLX.Robot[nRobotNumberSelected].RobotAxes[io.nAxis].FeedbackData.UserData /
        io.aMaxAxisSpeeds[io.nAxis] );

    CALIBTYPE_TCP:
      CASE io.nAxis OF
        0..2:
          io.fActualSpeed :=
            100 *
            ABS(tcpSpeeds[nRobotNumberSelected] /
              MLX.Robot[nRobotNumberSelected].ConfigurationData.MaxLinearSpeed);
        ELSE
          io.fActualSpeed :=
            100 *
            ABS(tcpSpeeds[nRobotNumberSelected] /
              MLX.Robot[nRobotNumberSelected].ConfigurationData.MaxAngularSpeed);
      END_CASE;
  END_CASE;
END_IF;


// -----------------------------------------------------------------------------
// measure min/max speed
// -----------------------------------------------------------------------------
IF bMeasuring THEN
  IF (io.fActualSpeed < fSpeedMin) THEN
    fSpeedMin := io.fActualSpeed;
  END_IF;
  IF (io.fActualSpeed > fSpeedMax) THEN
    fSpeedMax := io.fActualSpeed;
  END_IF;
END_IF;


// -----------------------------------------------------------------------------
// FB calls
// -----------------------------------------------------------------------------
fbSelectTool( MLX := MLX );
// stSetUserFrame( MLX := MLX );

// -------------------------------------
// get properties
// -------------------------------------
fbGetProperties.RobotNumber := nRobotNumberSelected;
fbGetProperties( MLX := MLX);

// -------------------------------------
// set properties
// -------------------------------------
fbSetProperties.RobotNumber := nRobotNumberSelected;
fbSetProperties( MLX := MLX);

// -------------------------------------
// move ptp
// -------------------------------------
fbMovePtp.RobotNumber := nRobotNumberSelected;
fbMovePtp.TargetType := 0;
fbMovePtp.BlendFactor := -1;
fbMovePtp.BlendType := 0;
fbMovePtp.Speed := 25;
fbMovePtp.Acceleration := 80;
fbMovePtp.Deceleration := 80;
fbMovePtp( MLX := MLX );

// -------------------------------------
// jog axis
// -------------------------------------
stJogAxis.nRobotNumber := nRobotNumberSelected;
stJogAxis.nQaMax := 1;
stJogAxis.bSystemReady := io.bSystemReady;
stJogAxis.bInchingMode := FALSE;
stJogAxis.fSpeed := fSpeed;
stJogAxis.aDelta[io.nAxis] := UINT_TO_REAL(io.nDelta) / 10;
fbJogAxis(
  io := stJogAxis,
  MLX := MLX);

// -------------------------------------
// jog TCP
// -------------------------------------
stJogTcp.nRobotNumber := nRobotNumberSelected;
stJogTcp.nQaMax := 1;
stJogTcp.bSystemReady := io.bSystemReady;
stJogTcp.bInchingMode := FALSE;
stJogTcp.nCoordFrame := 0;
stJogTcp.bUseRotationalSpeed := (io.nAxis > 2);
stJogTcp.fSpeed := fSpeed;
stJogTcp.aDelta[io.nAxis] := UINT_TO_REAL(io.nDelta) / 10;
fbJogTcp(
  io := stJogTcp,
  MLX := MLX);
