// -----------------------------------------------------------------------------
// init
// -----------------------------------------------------------------------------
stIO.bError := FALSE;
fbGetMessageDetail.Enable := FALSE;
fbPollInterval.IN := FALSE;


// -----------------------------------------------------------------------------
// poll interval (allow fast readings only in some system states)
// -----------------------------------------------------------------------------
CASE stMLX.SystemState OF
  6,
  8,
  12,
  13:
    fbPollInterval.PT := stIO.tPollInterval;

  ELSE
    fbPollInterval.PT := (5 * stIO.tPollInterval);
END_CASE;

IF NOT stMLX.Signals.RemoteMode THEN
  fbPollInterval.PT := stIO.tPollInterval;
END_IF;


// -----------------------------------------------------------------------------
// State machine 1: read warnings
// -----------------------------------------------------------------------------
CASE stIO.nSmReadWarnings OF
  // -------------------------------------
  // idle
  // -------------------------------------
  0:
    IF stMLX.Signals.MLXGatewayConnected THEN
      // init
      nIndex := 0;
      MEMUtils.MemSet(
        pbyBuffer := ADR(aWarningBuffer),
        byValue := 0,
        dwSize := SIZEOF(aWarningBuffer));

      stIO.nSmReadWarnings := 10;
    ELSE
      // clear old data
      stIO.nWarnings := 0;
      MEMUtils.MemSet(
        pbyBuffer := ADR(stIO.aWarnings),
        byValue := 0,
        dwSize := SIZEOF(stIO.aWarnings));
    END_IF;

  // -------------------------------------
  // read warning with MLxGetMessageDetail
  // -------------------------------------
  10:
    fbGetMessageDetail.Enable := TRUE;
    fbPollInterval.IN := TRUE;
    IF fbGetMessageDetail.Sts_EN AND fbGetMessageDetail.Sts_DN THEN
      IF fbGetMessageDetail.Sts_ER THEN
        stIO.nErrorCode := 1000 + stIO.nSmReadWarnings;
        stIO.nSmReadWarnings := 99;
      ELSE
        IF (fbGetMessageDetail.MessageDetail.ExtendedDescription1 <> '') THEN
          // store warning in buffer
          nIndex := LIMIT(0, nIndex, GVL.WARNINGS_UBOUND);
          aWarningBuffer[nIndex] :=
            CONCAT(
              STR1 := fbGetMessageDetail.MessageDetail.ExtendedDescription1,
              STR2 := fbGetMessageDetail.MessageDetail.ExtendedDescription2);
          nIndex := nIndex + 1;
        END_IF;

        // the errorNumber returns the "warning slot number" (0..9) so let's
        // use it to detect when the polling sequence is complete
        IF (fbGetMessageDetail.MessageDetail.errorNumber < 9 ) THEN
          stIO.nSmReadWarnings := 20;
        ELSE;
          stIO.nSmReadWarnings := 30;
        END_IF;
      END_IF;
    END_IF;

    IF NOT stMLX.Signals.MLXGatewayConnected THEN
      stIO.nSmReadWarnings := 0;
    END_IF;

  // -------------------------------------
  // poll delay
  // -------------------------------------
  20:
    fbPollInterval.IN := TRUE;
    IF fbPollInterval.Q THEN
      fbPollInterval.IN := FALSE;
      stIO.nSmReadWarnings := 10;
    END_IF;

  // -------------------------------------
  // poll sequence complete
  // -------------------------------------
  30:
    stIO.nWarnings := nIndex;
    stIO.aWarnings := aWarningBuffer;
    stIO.nSmReadWarnings := 0;

  // -------------------------------------
  // state machine error
  // -------------------------------------
  99:
    stIO.bError := TRUE;
    stIO.nSmReadWarnings := 0;

  ELSE
    stIO.nSmReadWarnings := 0;
END_CASE;


// -----------------------------------------------------------------------------
// outputs
// -----------------------------------------------------------------------------
stIO.bPollingCompleted := (stIO.nSmReadWarnings = 30);


// -----------------------------------------------------------------------------
// FB calls
// -----------------------------------------------------------------------------
fbGetMessageDetail(MLX := stMLX);
fbPollInterval();