// -----------------------------------------------------------------------------
// init
// -----------------------------------------------------------------------------
stIO.bError := FALSE;
fbResetAndHold.Enable := FALSE;
fbGetErrorDetail .Enable := FALSE;


// -----------------------------------------------------------------------------
// common
// -----------------------------------------------------------------------------
// rising edge signals
bOsrReset := stIO.bReset AND NOT aOneShots[0];
aOneShots[0] := stIO.bReset;


// -----------------------------------------------------------------------------
// State machine 1: read alarms
// -----------------------------------------------------------------------------
CASE stIO.nSmReadAlarms OF
  // -------------------------------------
  // idle, wait for new alarm data
  // -------------------------------------
  0:
    IF (stIO.nAlarms <> stMLX.NumberOfQueuedErrors)
      AND stMLX.Signals.MLXGatewayConnected THEN

      stIO.nAlarms := DINT_TO_USINT(stMLX.NumberOfQueuedErrors);
      stIO.nErrorCode := 0;
      stIO.nSmReadAlarms := 10;
    END_IF;

  // -------------------------------------
  // prepare reading
  // -------------------------------------
  10:
    nIndex := 0;
    MEMUtils.MemSet(
      pbyBuffer := ADR(stIO.aAlarms),
      byValue := 0,
      dwSize := SIZEOF(stIO.aAlarms));

    IF (stIO.nAlarms > 0) THEN
      stIO.nSmReadAlarms := 20;
    ELSE
      stIO.nSmReadAlarms := 0;
    END_IF;

  // -------------------------------------
  // read alarm with MLxGetErrorDetail
  // -------------------------------------
  20:
    fbGetErrorDetail.Enable := TRUE;
    IF fbGetErrorDetail.Sts_EN AND fbGetErrorDetail.Sts_DN THEN
      IF fbGetErrorDetail.Sts_ER THEN
        stIO.nErrorCode := 1000 + stIO.nSmReadAlarms;
        stIO.nSmReadAlarms := 99;
      ELSE
        // store alarm information
        stIO.aAlarms[nIndex].nAlarmNumber :=
          fbGetErrorDetail.ErrorDetail.errorNumber;

        MEMUtils.MemCpy(
          pbySrc := ADR(fbGetErrorDetail.ErrorDetail.Message),
          pbyDest := ADR(stIO.aAlarms[nIndex].sMessage),
          dwSize := SIZEOF(stIO.aAlarms[nIndex].sMessage));

        MEMUtils.MemCpy(
          pbySrc := ADR(fbGetErrorDetail.ErrorDetail.ExtendedDescription1),
          pbyDest := ADR(stIO.aAlarms[nIndex].sSubCode),
          dwSize := SIZEOF(stIO.aAlarms[nIndex].sSubCode));

        MEMUtils.MemCpy(
          pbySrc := ADR(fbGetErrorDetail.ErrorDetail.TimeStamp),
          pbyDest := ADR(stIO.aAlarms[nIndex].sTimeStamp),
          dwSize := SIZEOF(stIO.aAlarms[nIndex].sTimeStamp));

        nIndex := nIndex + 1;
        stIO.nSmReadAlarms := 30;
      END_IF;
    END_IF;

  // -------------------------------------
  // check if done
  // -------------------------------------
  30:
    // more errors to read
    IF nIndex < stIO.nAlarms THEN
      stIO.nSmReadAlarms := 20;
    // done
    ELSE
      stIO.nSmReadAlarms := 0;
    END_IF;

  // -------------------------------------
  // state machine error
  // -------------------------------------
  99:
    stIO.bError := TRUE;
    stIO.nSmReadAlarms := 0;

  ELSE
    stIO.nSmReadAlarms := 0;

END_CASE;


// -----------------------------------------------------------------------------
// outputs
// -----------------------------------------------------------------------------
stIO.bAlarmActive := (stMLX.NumberOfQueuedErrors <> 0);


// -----------------------------------------------------------------------------
// State machine 2: reset alarm
// -----------------------------------------------------------------------------
CASE stIO.nSmResetAlarm OF
  // -------------------------------------
  // idle
  // -------------------------------------
  0:
    IF bOsrReset AND stMLX.Signals.RemoteMode
      AND stMLX.Signals.MLXGatewayConnected THEN
      stIO.nErrorCode := 0;
      stIO.nSmResetAlarm := 10;
    END_IF;

  // -------------------------------------
  // reset alarm
  // -------------------------------------
  10:
    fbResetAndHold.Enable := TRUE;
    IF fbResetAndHold.Sts_EN AND fbResetAndHold.Sts_DN THEN
      IF fbResetAndHold.Sts_ER THEN
        stIO.nErrorCode := 2000 + stIO.nSmResetAlarm;
        stIO.nSmResetAlarm := 99;
      ELSE
        stIO.nSmResetAlarm := 0;
      END_IF;
    END_IF;

  // -------------------------------------
  // state machine error
  // -------------------------------------
  99:
    stIO.bError := TRUE;
    stIO.nSmResetAlarm := 0;

END_CASE;


// -----------------------------------------------------------------------------
// outputs
// -----------------------------------------------------------------------------
stIO.bResetIndicator := (stIO.bAlarmActive AND stBlinkSignals.bSlow)
                      OR ((stIO.nSmResetAlarm = 10) AND stBlinkSignals.bFast);


// -----------------------------------------------------------------------------
// FB calls
// -----------------------------------------------------------------------------
fbGetErrorDetail(MLX := stMLX);
fbResetAndHold(MLX := stMLX);