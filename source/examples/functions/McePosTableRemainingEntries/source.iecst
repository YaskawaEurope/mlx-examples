IF (index < 0) OR (index > (posTableSize - 1)) THEN
  McePosTableRemainingEntries := 0;
  RETURN;
END_IF;

nCount := - 1;

// -------------------------------------
// forward direction
// -------------------------------------
// search through the remaining part of the array
FOR i := index TO (posTableSize - 1) DO
  IF NOT posTable.stEntry[i].bSkipEntry THEN
    nCount := nCount + 1;

    // entry with Interlock
    bInterlock := FALSE;
    IF (posTable.stEntry[i].nInterlock > 0) THEN
      bInterlock := interlockFlags[posTable.stEntry[i].nInterlock - 1];
    END_IF

    // entry with standstill action or interlock, stop searching
    IF (posTable.stEntry[i].nActionID > 0) OR bInterlock THEN
      McePosTableRemainingEntries := nCount;
      RETURN;

    // last move, ignore further entries
    ELSIF posTable.stEntry[i].bLastEntry THEN
      EXIT;
    END_IF;
  END_IF;
END_FOR;

// search through the first part of the array
IF rollOver THEN
  FOR i := 0 TO index DO
    IF NOT posTable.stEntry[i].bSkipEntry THEN
      nCount := nCount + 1;

      // entry with Interlock
      bInterlock := FALSE;
      IF (posTable.stEntry[i].nInterlock > 0) THEN
        bInterlock := interlockFlags[posTable.stEntry[i].nInterlock - 1];
      END_IF

      // entry with standstill action or interlock, stop searching
      IF (posTable.stEntry[i].nActionID > 0) OR bInterlock THEN
        McePosTableRemainingEntries := nCount;
        RETURN;

      // last move, ignore further entries
      ELSIF posTable.stEntry[i].bLastEntry THEN
        EXIT;
      END_IF;
    END_IF;
  END_FOR;
  // unlimited entries to go
  nCount := 9999;
END_IF;

McePosTableRemainingEntries := nCount;
