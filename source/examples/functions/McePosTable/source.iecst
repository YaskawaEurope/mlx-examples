// -----------------------------------------------------------------------------
// common
// -----------------------------------------------------------------------------
bOsrStep := io.bStep AND NOT aOneShots[0];
aOneShots[0] := io.bStep;
bOsrSystemReady := io.bSystemReady AND NOT aOneShots[1];
aOneShots[1] := io.bSystemReady;
bOsrRecalcQA := io.bRecalcQA AND NOT aOneShots[2];
aOneShots[2] := io.bRecalcQA;
bOsfRun := NOT io.bRun AND aOneShots[3];
aOneShots[3] := io.bRun;

nPosTableSize := UINT_TO_INT(SIZEOF(posTable) / SIZEOF(posTable.stEntry[0]));
bLastEntryInProcess := posTable.stEntry[io.nIndex].bLastEntry OR (io.nIndex = (nPosTableSize - 1));
bOsfLastMoveInProcess := NOT bLastEntryInProcess AND aOneShots[4];
aOneShots[4] := bLastEntryInProcess;

bOsrRun := io.bRun AND NOT aOneShots[5];
aOneShots[5] := io.bRun;

// Count the number of cycles
IF bOsfLastMoveInProcess AND io.bBusy THEN
  io.nCycleNr := io.nCycleNr + 1;
END_IF;

bWaiting := FALSE;

bAllowQueuing := (io.nMode = 0) AND io.bRun;

bStopAfterLastEntry := ((io.nCycleNr + 1) >= io.nNrOfCycles) AND NOT (io.nNrOfCycles = 0);

// clear Enable signals
MEMUtils.MemSet(pbyBuffer := ADR(aEnable), byValue :=  0, dwSize :=  SIZEOF(aEnable));
io.bError := FALSE;

// Update QA
IF bOsrRecalcQA OR bOsrSystemReady THEN
  bFirstMove := bOsrSystemReady OR bOsrRun; // True if first move after standstill, False if QA recalculation is needed
  McePosTableRecalcQA(allowQueuing := bAllowQueuing,
                    firstMove := bFirstMove,
                    stopAfterLastEntry := bStopAfterLastEntry,
                    posTable := posTable,
                    QA := nQA,
                    lastEntry := bLastEntry,
                    stopEntry := bStopEntry,
                    index := io.nIndex
                    );
END_IF

// -----------------------------------------------------------------------------
// state machine 1: Motion
// -----------------------------------------------------------------------------
CASE io.nSmPosTable OF
  // -------------------------------------
  // state 0 - idle, not ready for start
  // -------------------------------------
  0:
    IF bOsfRun THEN
      io.nSmPosTable := 60;
    ELSIF io.bSystemReady THEN
      io.nErrorCode := 0;
      io.nSmPosTable := 1;
    END_IF

  // -------------------------------------
  // state 1 - idle, ready for start
  // -------------------------------------
  1:
    IF NOT io.bSystemReady THEN
      io.nSmPosTable := 0;
    ELSIF bOsfRun THEN
      io.nSmPosTable := 60;
    ELSIF io.bSystemReady THEN

      bWaiting := (io.nMode = 2);
      bFirstMove := TRUE;

      IF ((io.nMode <> 2 AND io.bRun) OR (io.nMode = 2 AND bOsrStep)) THEN
        McePosTableUpdateIndex( allowQueuing := bAllowQueuing,
                                firstMove := bFirstMove,
                                stopAfterLastEntry := bStopAfterLastEntry,
                                index := io.nIndex,
                                QA := nQA,
                                lastEntry := bLastEntry,
                                stopEntry := bStopEntry,
                                posTable := posTable);
        io.nSmPosTable := 10;
      END_IF
    END_IF

  // -------------------------------------
  // state 10..29 - handle motion commands
  // -------------------------------------
  10..29:
    FOR i := 0 TO QA_MAX DO
      nInstanceNumber[i] := io.nSmPosTable + DINT_TO_INT(i) - 10;
      IF nInstanceNumber[i] > QA_MAX THEN
        nInstanceNumber[i] := nInstanceNumber[i] - (QA_MAX + 1);
      END_IF;
    END_FOR;

    IF NOT io.bRun AND ((io.nAbortingMode = 1) OR NOT io.bSystemReady) THEN
      io.nSmPosTable := 50;
    ELSIF io.bSystemReady THEN
      // start this motion
      aEnable[nInstanceNumber[0]] := TRUE;

      // queue next motions
      FOR i := 1 TO QA_MAX DO
        aEnable[nInstanceNumber[i]] := (aMoveCmd[nInstanceNumber[i-1]].bSts_EN AND aMoveCmd[nInstanceNumber[i-1]].bSts_DN) AND (nQA >= i);
      END_FOR;

      // motion completed
      IF (aMoveCmd[nInstanceNumber[0]].bSts_EN AND aMoveCmd[nInstanceNumber[0]].bSts_PC) THEN
        IF NOT io.bRun AND (nQA = 0) THEN
          io.nSmPosTable := 50;
        ELSIF bStopEntry THEN
          io.nSmPosTable := 30;
        ELSIF bLastEntry THEN
          io.nSmPosTable := 40;
        ELSE
          bWaiting := (io.nMode = 2);
          IF (io.nMode <> 2 AND io.bRun) OR (bOsrStep OR (nQA > 0)) THEN
            aEnable[nInstanceNumber[0]] := FALSE;
            McePosTableUpdateIndex( allowQueuing := bAllowQueuing,
                                    firstMove := bFirstMove,
                                    stopAfterLastEntry := bStopAfterLastEntry,
                                    index := io.nIndex,
                                    QA := nQA,
                                    lastEntry := bLastEntry,
                                    stopEntry := bStopEntry,
                                    posTable := posTable);
            io.nSmPosTable := nInstanceNumber[1] + 10;
          END_IF;
        END_IF;
      END_IF;
    END_IF;

  // -------------------------------------
  // state 30 - waiting before performing action at standstill
  // -------------------------------------
  30:
    IF NOT io.bRun THEN
      io.nSmPosTable := 50;
    ELSIF io.bSystemReady THEN
        bWaiting := (io.nMode = 2);
        IF (io.nMode <> 2) OR bOsrStep THEN
            io.nSmPosTable := 31;
        END_IF;
    END_IF;

  // -------------------------------------
  // state 31 - perform action at standstill
  // -------------------------------------
  31:
    IF NOT io.bRun THEN
      io.nSmPosTable := 50;
    ELSIF io.bSystemReady THEN
      bWaiting := (bDefaultActionDone OR io.bCustomActionDone) AND (io.nMode = 2);
      bCustomActionDone := io.bCustomActionDone AND (io.nCustomActionNumber = io.nActionID) AND io.nCustomActionNumber > RESERVED_ACTIONID_NUMBER;
      IF (bDefaultActionDone OR bCustomActionDone) AND ((io.nMode <> 2) OR bOsrStep) THEN
        IF bLastEntry AND (io.nNrOfCycles - io.nCycleNr <= 1) THEN
          io.nSmPosTable := 40;
        ELSE
          McePosTableUpdateIndex( allowQueuing := bAllowQueuing,
                                  firstMove := bFirstMove,
                                  stopAfterLastEntry := bStopAfterLastEntry,
                                  index := io.nIndex,
                                  QA := nQA,
                                  lastEntry := bLastEntry,
                                  stopEntry := bStopEntry,
                                  posTable := posTable);
          io.nSmPosTable := 10;
        END_IF
      END_IF
    END_IF;

  // -------------------------------------
  // state 40 - cycle completed
  // -------------------------------------
  40:
    io.nCycleNr := io.nCycleNr + 1;

    IF NOT io.bRun THEN
          io.nSmPosTable := 50;
    ELSIF ((io.nCycleNr < io.nNrOfCycles) OR (io.nNrOfCycles = 0)) AND (io.nMode <> 2) THEN
      McePosTableUpdateIndex( allowQueuing := bAllowQueuing,
                              firstMove := bFirstMove,
                              stopAfterLastEntry := FALSE,
                              index := io.nIndex,
                              QA := nQA,
                              lastEntry := bLastEntry,
                              stopEntry := bStopEntry,
                              posTable := posTable);
      io.nSmPosTable := 10;
    ELSE
      io.nSmPosTable := 50;
    END_IF;

  // -------------------------------------
  // state 50 - wait at the end of cycle
  // -------------------------------------
  50:
    IF NOT io.bRun THEN
      io.nSmPosTable := 60;
    END_IF;

  // -------------------------------------
  // state 60 - reset cycle
  // -------------------------------------
  60:
    io.nIndex := 0;
    io.nLoadIndex := 0;
    io.nCycleNr := 0;

    io.nSmPosTable := 0;

  // -------------------------------------
  // state 99 - state machine error
  // -------------------------------------
  99:
    io.bError := TRUE;

    IF NOT io.bRun THEN
      io.nSmPosTable := 60;
    END_IF;
END_CASE;

// -----------------------------------------------------------------------------
// actions
// -----------------------------------------------------------------------------
io.bActionStart := (io.nSmPosTable = 31);
io.nActionID := posTable.stEntry[io.nIndex].nActionID;

IF io.bActionStart THEN
  // map PosTable actions
  CASE io.nActionID OF
    ACTIONID_NO_ACTION:
      bDefaultActionDone := TRUE;

    ACTIONID_WAIT_ONE_SCAN:
      bDefaultActionDone := TRUE;

    ACTIONID_WAIT_STEP:
      bWaiting := TRUE;
      bDefaultActionDone := bOsrStep;
  ELSE
    bDefaultActionDone := io.nActionID <= RESERVED_ACTIONID_NUMBER;
  END_CASE;
ELSE
  bDefaultActionDone := FALSE;
END_IF;

// -----------------------------------------------------------------------------
// state monitoring
// Waiting condition is used to exclude the time where it is waiting for the Step button
// -----------------------------------------------------------------------------
io.nStateTime := MceStateMonitoring(nState := io.nSmPosTable,
                                      bFreezeTimer := bWaiting OR NOT io.bSystemReady OR (io.nSmPosTable >= 40) OR (io.nSmPosTable < 10),
                                      stateData := stStateMonitoringData);

// -----------------------------------------------------------------------------
// process move commands
// -----------------------------------------------------------------------------
// Rising edge signals of Enable
FOR i := 0 TO QA_MAX DO
  aOsrEnable[i] := aEnable[i] AND NOT aOneShots[i+6];
  aOneShots[i+6] := aEnable[i];
END_FOR;

// map parameterdata to move FB's
FOR i := 0 TO QA_MAX DO
  IF aOsrEnable[i] THEN

    McePosTableUpdateLoadIndex( allowQueuing := bAllowQueuing,
                                firstMove := bFirstMove,
                                stopAfterLastEntry := ((io.nCycleNr + 1) >= io.nNrOfCycles) AND NOT (io.nNrOfCycles = 0),
                                index := io.nIndex,
                                loadIndex := io.nLoadIndex,
                                QA := nQA,
                                posTable := posTable);
    aUseMoveType[i] := posTable.stEntry[io.nLoadIndex].bMoveType;

    IF aUseMoveType[i] = 1 THEN
      // -----------------------------------------------------------------------------
      // mapping linear move FB'S
      // -----------------------------------------------------------------------------
      fbRobotMoveLinearAbsolute[i].RobotNumber := io.nRobotNumber;
      fbRobotMoveLinearAbsolute[i].TargetType := posTable.stEntry[io.nLoadIndex].bTargetType;

      // target position
      MEMUtils.MemSet(pbyBuffer := ADR(fbRobotMoveLinearAbsolute[i].TargetPosition), byValue :=  0, dwSize :=  SIZEOF(fbRobotMoveLinearAbsolute[i].TargetPosition));
      IF posTable.stEntry[io.nLoadIndex].bTargetType THEN
        // as TCP position
        MEMUtils.MemCpy(pbyDest := ADR(fbRobotMoveLinearAbsolute[i].TargetPosition.TCPPosition.TCPPosition), pbySrc :=  ADR(posTable.stEntry[io.nLoadIndex].aPosition), dwSize :=  SIZEOF(posTable.stEntry[io.nLoadIndex].aPosition));
      ELSE
        // as axis positions
        MEMUtils.MemCpy(pbyDest := ADR(fbRobotMoveLinearAbsolute[i].TargetPosition.AxisPosition), pbySrc :=  ADR(posTable.stEntry[io.nLoadIndex].aPosition), dwSize :=  SIZEOF(posTable.stEntry[io.nLoadIndex].aPosition));
      END_IF;

      // blending between motions
      fbRobotMoveLinearAbsolute[i].BlendFactor := SINT_TO_DINT(posTable.stEntry[io.nLoadIndex].nBlendFactor);
      fbRobotMoveLinearAbsolute[i].BlendType := 0;
      fbRobotMoveLinearAbsolute[i].Speed := posTable.stEntry[io.nLoadIndex].fSpeed;
      fbRobotMoveLinearAbsolute[i].UseRotationalSpeed := posTable.stEntry[io.nLoadIndex].bUseRotationalSpeed;
      fbRobotMoveLinearAbsolute[i].SpeedUnits := posTable.stEntry[io.nLoadIndex].nSpeedUnits;
      fbRobotMoveLinearAbsolute[i].Acceleration := SINT_TO_REAL(posTable.stEntry[io.nLoadIndex].nAcc);
      fbRobotMoveLinearAbsolute[i].Deceleration := SINT_TO_REAL(posTable.stEntry[io.nLoadIndex].nDec);
    ELSE
      // -----------------------------------------------------------------------------
      // mapping PtP move FB's
      // -----------------------------------------------------------------------------
      fbRobotMoveAxisAbsolute[i].RobotNumber := io.nRobotNumber;
      fbRobotMoveAxisAbsolute[i].TargetType := posTable.stEntry[io.nLoadIndex].bTargetType;

      // target position
      MEMUtils.MemSet(pbyBuffer := ADR(fbRobotMoveAxisAbsolute[i].TargetPosition), byValue :=  0, dwSize :=  SIZEOF(fbRobotMoveAxisAbsolute[i].TargetPosition));
      IF posTable.stEntry[io.nLoadIndex].bTargetType THEN
        // as TCP position
        MEMUtils.MemCpy(pbyDest := ADR(fbRobotMoveAxisAbsolute[i].TargetPosition.TCPPosition.TCPPosition), pbySrc :=  ADR(posTable.stEntry[io.nLoadIndex].aPosition), dwSize :=  SIZEOF(posTable.stEntry[io.nLoadIndex].aPosition));

      ELSE
        // as axis positions
        MEMUtils.MemCpy(pbyDest := ADR(fbRobotMoveAxisAbsolute[i].TargetPosition.AxisPosition), pbySrc :=  ADR(posTable.stEntry[io.nLoadIndex].aPosition), dwSize :=  SIZEOF(posTable.stEntry[io.nLoadIndex].aPosition));
      END_IF;

      // blending between motions
      fbRobotMoveAxisAbsolute[i].BlendFactor := SINT_TO_DINT(posTable.stEntry[io.nLoadIndex].nBlendFactor);
      fbRobotMoveAxisAbsolute[i].BlendType := 0;
      fbRobotMoveAxisAbsolute[i].Speed := posTable.stEntry[io.nLoadIndex].fSpeed;
      fbRobotMoveAxisAbsolute[i].Acceleration := SINT_TO_REAL(posTable.stEntry[io.nLoadIndex].nAcc);
      fbRobotMoveAxisAbsolute[i].Deceleration := SINT_TO_REAL(posTable.stEntry[io.nLoadIndex].nDec);
    END_IF;

    // -----------------------------------------------------------------------------
    // mapping SetUserFrame FB's
    // -----------------------------------------------------------------------------
    fbRobotSetUserFrame[i].RobotNumber := io.nRobotNumber;
    nUserFrameNr := SINT_TO_DINT(posTable.stEntry[io.nLoadIndex].nUserFrameNumber);
    fbRobotSetUserFrame[i].UserFrameNumber := nUserFrameNr;
    fbRobotSetUserFrame[i].UserFrameData.CoordFrame := userFrames.aFrames[nUserFrameNr].aVector;

    // change user frame; if the user frame number differs from the previous stEntry a MLxRobotSetUserFrame will be triggered just before the move
    aChangeUserFrame[i] := bFirstMove OR (nUserFrameNr <> INT_TO_DINT(MLX.Robot[io.nRobotNumber].ActiveUserFrameNumber));

    // -----------------------------------------------------------------------------
    // mapping ToolSelect FB's
    // -----------------------------------------------------------------------------
    fbRobotSelectTool[i].RobotNumber := io.nRobotNumber;
    nToolNr := SINT_TO_DINT(posTable.stEntry[io.nLoadIndex].nToolNumber);
    fbRobotSelectTool[i].ToolNumber := nToolNr;
    fbRobotSelectTool[i].ToolData := tools.aTools[nToolNr];

    // change (select) tool; if the tool number differs from the previous stEntry a MLxRobotSelectTool will be triggered just before the move
    aChangeTool[i] := bFirstMove OR (nToolNr <> INT_TO_DINT(MLX.Robot[io.nRobotNumber].ActiveToolNumber));
    bFirstMove := FALSE;
  END_IF;
END_FOR;

// map Enable signals to move FB's
FOR i := 0 TO QA_MAX DO
  fbRobotMoveAxisAbsolute[i].Enable := aEnable[i] AND NOT (aUseMoveType[i] = 1) AND (NOT aChangeUserFrame[i] OR (fbRobotSetUserFrame[i].Sts_EN AND fbRobotSetUserFrame[i].Sts_DN AND NOT fbRobotSetUserFrame[i].Sts_ER));
  fbRobotMoveLinearAbsolute[i].Enable := aEnable[i] AND (aUseMoveType[i] = 1) AND (NOT aChangeUserFrame[i] OR (fbRobotSetUserFrame[i].Sts_EN AND fbRobotSetUserFrame[i].Sts_DN AND NOT fbRobotSetUserFrame[i].Sts_ER));
  fbRobotSetUserFrame[i].Enable := aEnable[i] AND aChangeUserFrame[i];
  fbRobotSelectTool[i].Enable := aEnable[i] AND aChangeTool[i];
END_FOR;

// -----------------------------------------------------------------------------
// FB calls (order is important!)
// -----------------------------------------------------------------------------
FOR i := 0 TO QA_MAX DO
  fbRobotSelectTool[i](MLX := MLX);
  fbRobotSetUserFrame[i](MLX := MLX);
END_FOR;
FOR i := 0 TO QA_MAX DO
  fbRobotMoveAxisAbsolute[i](MLX := MLX);
  fbRobotMoveLinearAbsolute[i](MLX := MLX);
END_FOR;

// -----------------------------------------------------------------------------
// map status signals from move FB's
// -----------------------------------------------------------------------------
FOR i := 0 TO QA_MAX DO
  IF aUseMoveType[i] = 1 THEN
    aMoveCmd[i].bSts_EN := fbRobotMoveLinearAbsolute[i].Sts_EN;
    aMoveCmd[i].bSts_DN := fbRobotMoveLinearAbsolute[i].Sts_DN;
    aMoveCmd[i].bSts_IP := fbRobotMoveLinearAbsolute[i].Sts_IP;
    aMoveCmd[i].bSts_AC := fbRobotMoveLinearAbsolute[i].Sts_AC;
    aMoveCmd[i].bSts_PC := fbRobotMoveLinearAbsolute[i].Sts_PC;
    aMoveCmd[i].bSts_ER := fbRobotMoveLinearAbsolute[i].Sts_ER;
    aMoveCmd[i].nPercentComplete := fbRobotMoveLinearAbsolute[i].PercentComplete;
  ELSE
    aMoveCmd[i].bSts_EN := fbRobotMoveAxisAbsolute[i].Sts_EN;
    aMoveCmd[i].bSts_DN := fbRobotMoveAxisAbsolute[i].Sts_DN;
    aMoveCmd[i].bSts_IP := fbRobotMoveAxisAbsolute[i].Sts_IP;
    aMoveCmd[i].bSts_AC := fbRobotMoveAxisAbsolute[i].Sts_AC;
    aMoveCmd[i].bSts_PC := fbRobotMoveAxisAbsolute[i].Sts_PC;
    aMoveCmd[i].bSts_ER := fbRobotMoveAxisAbsolute[i].Sts_ER;
    aMoveCmd[i].nPercentComplete := fbRobotMoveAxisAbsolute[i].PercentComplete;
  END_IF;
END_FOR;

// -----------------------------------------------------------------------------
// map nPercentComplete
// -----------------------------------------------------------------------------
CASE io.nSmPosTable OF
  10..29:
    io.nPercentComplete := aMoveCmd[nInstanceNumber[0]].nPercentComplete;
  30..50:
    io.nPercentComplete := 100;
  ELSE
    io.nPercentComplete := 0;
END_CASE;

// -----------------------------------------------------------------------------
// PosTable status
// -----------------------------------------------------------------------------
io.bWaitForStep := bWaiting;
io.bDone := (io.nSmPosTable = 50);
io.bIdle := (io.nSmPosTable < 10);
io.bBusy := (io.nSmPosTable >= 10 AND io.nSmPosTable < 50);
bError := MLX.JoggingMode;
FOR i := 0 TO QA_MAX DO
  bError := bError OR (aMoveCmd[i].bSts_EN AND aMoveCmd[i].bSts_ER)
        OR (fbRobotSelectTool[i].Sts_EN AND fbRobotSelectTool[i].Sts_ER)
        OR (fbRobotSetUserFrame[i].Sts_EN AND fbRobotSetUserFrame[i].Sts_ER);
END_FOR
IF bError THEN
  io.nErrorCode := 1000 + INT_TO_UDINT(io.nSmPosTable);
  io.nSmPosTable := 99;
END_IF