// -----------------------------------------------------------------------------
// common
// -----------------------------------------------------------------------------
bReCmdStep := stIO.bCmdStep AND NOT aONS[3];
aONS[3] := stIO.bCmdStep;
bReSystemReady := stIO.bSystemReady AND NOT aONS[4];
aONS[4] := stIO.bSystemReady;
bReRecalcQA := stIO.bRecalcQA AND NOT aONS[5];
aONS[5] := stIO.bRecalcQA;
bFeCmdRun := NOT stIO.bCmdRun AND aONS[6];
aONS[6] := stIO.bCmdRun;
bReReset := stIO.bCmdReset AND NOT aONS[7];
aONS[7] := stIO.bCmdReset;

nPosTableSize := nPosTableSize := UINT_TO_INT(SIZEOF(stPosTable) / SIZEOF(stPosTable.stEntry[0]));
bLastEntryInProcess := stPosTable.stEntry[stIO.nIndex].bLastEntry OR (stIO.nIndex = (nPosTableSize - 1));
bFeLastMoveInProcess := NOT bLastEntryInProcess AND aONS[8];
aONS[8] := bLastEntryInProcess;

bReCmdRun := stIO.bCmdRun AND NOT aONS[9];
aONS[9] := stIO.bCmdRun;

// Stop request
IF (bFeCmdRun AND (stIO.nPosTableMode <> 2)) OR bReReset THEN
  bStopRequest := TRUE;
END_IF;

// Reset request
IF bReReset THEN
  bResetRequest := TRUE;
END_IF;

// Count the number of cycle
IF bFeLastMoveInProcess AND stIO.bBusy THEN
  stIO.nCycleNr := stIO.nCycleNr + 1;
END_IF;

bWaiting := FALSE;

// clear Enable signals
MEMUtils.MemSet(pbyBuffer := ADR(aEnable), byValue :=  0, dwSize :=  SIZEOF(aEnable));
stIO.bError := FALSE;

// Update QA
IF bReRecalcQA THEN
  bFirstMove := bReSystemReady OR bReCmdRun; // True if first move after standstill, False if QA recalculation is needed
  McePosTableRecalcQA(nPosTableMode := stIO.nPosTableMode,
                    bFirstMove := bFirstMove,
                    bStopRequest := bStopRequest,
                    bStopAfterLastEntry := ((stIO.nCycleNr + 1) >= stIO.nNrOfCycles) AND NOT (stIO.nNrOfCycles = 0),
                    stPosTable := stPosTable,
                    nQA := nQA,
                    bLastEntry := bLastEntry,
                    bStopEntry := bStopEntry,
                    nIndex := stIO.nIndex
                    );
END_IF

// -----------------------------------------------------------------------------
// state machine 1: Motion
// -----------------------------------------------------------------------------
CASE stIO.nSmPosTable OF
  // -------------------------------------
  // state 0 - idle, not ready for start
  // -------------------------------------
  0:
    bStopRequest := FALSE;

    IF bResetRequest THEN
      stIO.nSmPosTable := 50;
    ELSIF stIO.bSystemReady THEN
      stIO.nErrorCode := 0;
      stIO.nSmPosTable := 1;
    END_IF

  // -------------------------------------
  // state 1 - idle, ready for start
  // -------------------------------------
  1:
    IF bStopRequest OR NOT stIO.bSystemReady THEN
      stIO.nSmPosTable := 0;
    ELSIF bResetRequest THEN
      stIO.nSmPosTable := 50;
    ELSIF stIO.bSystemReady THEN

      bWaiting := TRUE;
      bFirstMove := TRUE;

      IF ((stIO.nPosTableMode <> 2 AND stIO.bCmdRun) OR bReCmdStep) AND NOT stIO.bCmdReset THEN
        McePosTableUpdateIndex( nPosTableMode := stIO.nPosTableMode,
                                bFirstMove := bFirstMove,
                                bStopRequest := bStopRequest,
                                bStopAfterLastEntry := ((stIO.nCycleNr + 1) >= stIO.nNrOfCycles) AND NOT (stIO.nNrOfCycles = 0),
                                nIndex := stIO.nIndex,
                                nQA := nQA,
                                bLastEntry := bLastEntry,
                                bStopEntry := bStopEntry,
                                stPosTable := stPosTable);
        stIO.nSmPosTable := 11;
      END_IF
    END_IF

  // -------------------------------------
  // state 11 - move to pos n / queue pos n+1, n+2 / user frame and tool change included
  // -------------------------------------
  11:
    IF stIO.bSystemReady THEN
      // start this motion
      aEnable[0] := TRUE;

      // queue next 2 motions
      aEnable[1] := (aMoveCmd[0].bSts_EN AND aMoveCmd[0].bSts_DN) AND (nQA >= 1);
      aEnable[2] := (aMoveCmd[1].bSts_EN AND aMoveCmd[1].bSts_DN) AND (nQA >= 2);

      // motion completed
      IF (aMoveCmd[0].bSts_EN AND aMoveCmd[0].bSts_PC) THEN
        IF bStopRequest AND (nQA = 0) THEN
          stIO.nSmPosTable := 0;
        ELSIF bStopEntry THEN
          stIO.nSmPosTable := 20;
        ELSIF bLastEntry THEN
          stIO.nSmPosTable := 30;
        ELSE
          bWaiting := (stIO.nPosTableMode = 2);
          IF (stIO.nPosTableMode <> 2 AND stIO.bCmdRun) OR (bReCmdStep OR (nQA > 0)) THEN
            aEnable[0] := FALSE;
            McePosTableUpdateIndex( nPosTableMode := stIO.nPosTableMode,
                                    bFirstMove := bFirstMove,
                                    bStopRequest := bStopRequest,
                                    bStopAfterLastEntry := ((stIO.nCycleNr + 1) >= stIO.nNrOfCycles) AND NOT (stIO.nNrOfCycles = 0),
                                    nIndex := stIO.nIndex,
                                    nQA := nQA,
                                    bLastEntry := bLastEntry,
                                    bStopEntry := bStopEntry,
                                    stPosTable := stPosTable);
            stIO.nSmPosTable := 12;
          END_IF;
        END_IF;
      END_IF;
    END_IF;

  // -------------------------------------
  // state 12 - move to pos n+1 / queue pos n+2, n / user frame and tool change included
  // -------------------------------------
  12:
    IF stIO.bSystemReady THEN
      // start this motion
      aEnable[1] := TRUE;

      // queue next 2 motions
      aEnable[2] := (aMoveCmd[1].bSts_EN AND aMoveCmd[1].bSts_DN) AND (nQA >= 1);
      aEnable[0] := (aMoveCmd[2].bSts_EN AND aMoveCmd[2].bSts_DN) AND (nQA >= 2);

      // motion completed
      IF (aMoveCmd[1].bSts_EN AND aMoveCmd[1].bSts_PC) THEN
        IF bStopRequest AND (nQA = 0) THEN
          stIO.nSmPosTable := 0;
        ELSIF bStopEntry THEN
          stIO.nSmPosTable := 20;
        ELSIF bLastEntry THEN
          stIO.nSmPosTable := 30;
        ELSE
          bWaiting := (stIO.nPosTableMode = 2);
          IF (stIO.nPosTableMode <> 2 AND stIO.bCmdRun) OR (bReCmdStep OR (nQA > 0)) THEN
            aEnable[1] := FALSE;
            McePosTableUpdateIndex( nPosTableMode := stIO.nPosTableMode,
                                    bFirstMove := bFirstMove,
                                    bStopRequest := bStopRequest,
                                    bStopAfterLastEntry := ((stIO.nCycleNr + 1) >= stIO.nNrOfCycles) AND NOT (stIO.nNrOfCycles = 0),
                                    nIndex := stIO.nIndex,
                                    nQA := nQA,
                                    bLastEntry := bLastEntry,
                                    bStopEntry := bStopEntry,
                                    stPosTable := stPosTable);
            stIO.nSmPosTable := 13;
          END_IF;
        END_IF;
      END_IF;
    END_IF;

  // -------------------------------------
  // state 13 - move to pos n+2 / queue pos n, n+1 / user frame and tool change included
  // -------------------------------------
  13:
    IF stIO.bSystemReady THEN
      // start this motion
      aEnable[2] := TRUE;

      // queue next 2 motions
      aEnable[0] := (aMoveCmd[2].bSts_EN AND aMoveCmd[2].bSts_DN) AND (nQA >= 1);
      aEnable[1] := (aMoveCmd[0].bSts_EN AND aMoveCmd[0].bSts_DN) AND (nQA >= 2);

      // motion completed
      IF (aMoveCmd[2].bSts_EN AND aMoveCmd[2].bSts_PC) THEN
        IF bStopRequest AND (nQA = 0) THEN
          stIO.nSmPosTable := 0;
        ELSIF bStopEntry THEN
          stIO.nSmPosTable := 20;
        ELSIF bLastEntry THEN
          stIO.nSmPosTable := 30;
        ELSE
          bWaiting := (stIO.nPosTableMode = 2);
          IF (stIO.nPosTableMode <> 2 AND stIO.bCmdRun) OR (bReCmdStep OR (nQA > 0)) THEN
            aEnable[2] := FALSE;
            McePosTableUpdateIndex( nPosTableMode := stIO.nPosTableMode,
                                    bFirstMove := bFirstMove,
                                    bStopRequest := bStopRequest,
                                    bStopAfterLastEntry := ((stIO.nCycleNr + 1) >= stIO.nNrOfCycles) AND NOT (stIO.nNrOfCycles = 0),
                                    nIndex := stIO.nIndex,
                                    nQA := nQA,
                                    bLastEntry := bLastEntry,
                                    bStopEntry := bStopEntry,
                                    stPosTable := stPosTable);
            stIO.nSmPosTable := 11;
          END_IF;
        END_IF;
      END_IF;
    END_IF;

  // -------------------------------------
  // state 20 - waiting before performing action at standstill
  // -------------------------------------
  20:
    IF bStopRequest THEN
      stIO.nSmPosTable := 0;
    ELSIF stIO.bSystemReady THEN
        bWaiting := (stIO.nPosTableMode = 2);
        IF (stIO.nPosTableMode <> 2) OR bReCmdStep THEN
            stIO.nSmPosTable := 21;
        END_IF;
    END_IF;

  // -------------------------------------
  // state 21 - perform action at standstill
  // -------------------------------------
  21:
    IF bStopRequest THEN
      stIO.nSmPosTable := 0;
    ELSIF stIO.bSystemReady THEN
      bWaiting := (bDefaultActionDone OR stIO.bCustomActionDone) AND (stIO.nPosTableMode = 2);
      IF (bDefaultActionDone OR stIO.bCustomActionDone) AND ((stIO.nPosTableMode <> 2) OR bReCmdStep) THEN
        IF bLastEntry AND (stIO.nNrOfCycles - stIO.nCycleNr <= 1) THEN
          stIO.nSmPosTable := 30;
        ELSE
          McePosTableUpdateIndex( nPosTableMode := stIO.nPosTableMode,
                                  bFirstMove := bFirstMove,
                                  bStopRequest := bStopRequest,
                                  bStopAfterLastEntry := ((stIO.nCycleNr + 1) >= stIO.nNrOfCycles) AND NOT (stIO.nNrOfCycles = 0),
                                  nIndex := stIO.nIndex,
                                  nQA := nQA,
                                  bLastEntry := bLastEntry,
                                  bStopEntry := bStopEntry,
                                  stPosTable := stPosTable);
          stIO.nSmPosTable := 11;
        END_IF
      END_IF
    END_IF;

  // -------------------------------------
  // state 30 - cycle completed
  // -------------------------------------
  30:
    stIO.nCycleNr := stIO.nCycleNr + 1;
    
    IF ((stIO.nCycleNr < stIO.nNrOfCycles) OR (stIO.nNrOfCycles = 0)) AND (stIO.nPosTableMode <> 2) THEN
      McePosTableUpdateIndex( nPosTableMode := stIO.nPosTableMode,
                              bFirstMove := bFirstMove,
                              bStopRequest := bStopRequest,
                              bStopAfterLastEntry := ((stIO.nCycleNr + 1) >= stIO.nNrOfCycles) AND NOT (stIO.nNrOfCycles = 0),
                              nIndex := stIO.nIndex,
                              nQA := nQA,
                              bLastEntry := bLastEntry,
                              bStopEntry := bStopEntry,
                              stPosTable := stPosTable);
      stIO.nSmPosTable := 11;
    ELSE
      stIO.nSmPosTable := 40;
    END_IF;

  // -------------------------------------
  // state 40 - wait at the end of cycle
  // -------------------------------------
  40:
    IF NOT stIO.bCmdRun THEN
      stIO.nSmPosTable := 50;
    END_IF;

  // -------------------------------------
  // state 50 - reset cycle
  // -------------------------------------
  50:
    stIO.nIndex := 0;
    stIO.nLoadIndex := 0;
    stIO.nCycleNr := 0;

    bResetRequest := FALSE;

    stIO.nSmPosTable := 0;

  // -------------------------------------
  // state 99 - state machine error
  // -------------------------------------
  99:
    stIO.bError := TRUE;

    IF bResetRequest AND NOT stIO.bCmdRun THEN
      stIO.nSmPosTable := 0;
    END_IF;
END_CASE;

// -----------------------------------------------------------------------------
// actions
// -----------------------------------------------------------------------------
stIO.bActionStart := (stIO.nSmPosTable = 21);
stIO.nActionID := stPosTable.stEntry[stIO.nIndex].nActionID;

IF stIO.bActionStart THEN
  // map PosTable actions
  CASE stIO.nActionID OF
    ACTIONID_NO_ACTION:
      bDefaultActionDone := TRUE;

    ACTIONID_WAIT_ONE_SCAN:
      bDefaultActionDone := TRUE;
  END_CASE;
ELSE
  bDefaultActionDone := FALSE;
END_IF;

// -----------------------------------------------------------------------------
// state monitoring
// Waiting condition is used to exclude the time where it is waiting for the Step button
// -----------------------------------------------------------------------------
stIO.nStateTime := MceStateMonitoring(nState := stIO.nSmPosTable,
                                      bFreezeTimer := bWaiting OR NOT stIO.bSystemReady OR (stIO.nSmPosTable >= 40),
                                      stStateData := stStateMonitoringData);

// -----------------------------------------------------------------------------
// process move commands
// -----------------------------------------------------------------------------
// Rising edge signals of Enable
aReEnable[0] := aEnable[0] AND NOT aONS[0];
aONS[0] := aEnable[0];
aReEnable[1] := aEnable[1] AND NOT aONS[1];
aONS[1] := aEnable[1];
aReEnable[2] := aEnable[2] AND NOT aONS[2];
aONS[2] := aEnable[2];

// map parameterdata to move FB's
FOR i := 0 TO QAmax DO
  IF aReEnable[i] THEN

    McePosTableUpdateLoadIndex( nPosTableMode := stIO.nPosTableMode,
                                bFirstMove := bFirstMove,
                                bStopAfterLastEntry := ((stIO.nCycleNr + 1) >= stIO.nNrOfCycles) AND NOT (stIO.nNrOfCycles = 0),
                                nIndex := stIO.nIndex,
                                nLoadIndex := stIO.nLoadIndex,
                                nQA := nQA,
                                stPosTable := stPosTable);
    aUseMoveType[i] := stPosTable.stEntry[stIO.nLoadIndex].bMoveType;

    IF aUseMoveType[i] = 1 THEN
      // -----------------------------------------------------------------------------
      // mapping linear move FB'S
      // -----------------------------------------------------------------------------
      aRobotMoveLinearAbsolute[i].RobotNumber := stIO.nRobotNumber;
      aRobotMoveLinearAbsolute[i].TargetType := stPosTable.stEntry[stIO.nLoadIndex].bTargetType;

      // target position
      MEMUtils.MemSet(pbyBuffer := ADR(aRobotMoveLinearAbsolute[i].TargetPosition), byValue :=  0, dwSize :=  SIZEOF(aRobotMoveLinearAbsolute[i].TargetPosition));
      IF stPosTable.stEntry[stIO.nLoadIndex].bTargetType THEN
        // as TCP position
        MEMUtils.MemCpy(pbyDest := ADR(aRobotMoveLinearAbsolute[i].TargetPosition.TCPPosition.TCPPosition), pbySrc :=  ADR(stPosTable.stEntry[stIO.nLoadIndex].aPosition), dwSize :=  SIZEOF(stPosTable.stEntry[stIO.nLoadIndex].aPosition));

        // activate the reference position for the S-axis by setting a value unequal to 0 degree
        // this will prevent the robot trying to move past the S-axis limit
        aRobotMoveLinearAbsolute[i].TargetPosition.TCPPosition.Closure.ReferencePosition[0] := 0.1;
        aRobotMoveLinearAbsolute[i].TargetPosition.TCPPosition.Closure.ReferencePosition[4] := - 0.1;
      ELSE
        // as axis positions
        MEMUtils.MemCpy(pbyDest := ADR(aRobotMoveLinearAbsolute[i].TargetPosition.AxisPosition), pbySrc :=  ADR(stPosTable.stEntry[stIO.nLoadIndex].aPosition), dwSize :=  SIZEOF(stPosTable.stEntry[stIO.nLoadIndex].aPosition));
      END_IF;

      // blending between motions
      IF (stPosTable.stEntry[stIO.nLoadIndex].nActionID > 0) AND (stPosTable.stEntry[stIO.nLoadIndex].nActionID < 50) THEN
        // IF (stPosTable.stEntry[stIO.nLoadIndex].nActionID <> 0) THEN
        // use exact stop position for action at standstill
        aRobotMoveLinearAbsolute[i].BlendFactor := 0;
      ELSE
        aRobotMoveLinearAbsolute[i].BlendFactor := SINT_TO_DINT(stPosTable.stEntry[stIO.nLoadIndex].nBlendFactor);
      END_IF;

      aRobotMoveLinearAbsolute[i].BlendType := 0;

      IF (stIO.fSpeedManipulation = 0) THEN
        aRobotMoveLinearAbsolute[i].Speed := stPosTable.stEntry[stIO.nLoadIndex].fSpeed;
      ELSE
        aRobotMoveLinearAbsolute[i].Speed := stPosTable.stEntry[stIO.nLoadIndex].fSpeed * (stIO.fSpeedManipulation / 100);
      END_IF;
      aRobotMoveLinearAbsolute[i].UseRotationalSpeed := stPosTable.stEntry[stIO.nLoadIndex].bUseRotationalSpeed;
      aRobotMoveLinearAbsolute[i].SpeedUnits := stPosTable.stEntry[stIO.nLoadIndex].nSpeedUnits;
      aRobotMoveLinearAbsolute[i].Acceleration := SINT_TO_REAL(stPosTable.stEntry[stIO.nLoadIndex].nAcc);
      aRobotMoveLinearAbsolute[i].Deceleration := SINT_TO_REAL(stPosTable.stEntry[stIO.nLoadIndex].nDec);
    ELSE
      // -----------------------------------------------------------------------------
      // mapping PtP move FB's
      // -----------------------------------------------------------------------------
      aRobotMoveAxisAbsolute[i].RobotNumber := stIO.nRobotNumber;
      aRobotMoveAxisAbsolute[i].TargetType := stPosTable.stEntry[stIO.nLoadIndex].bTargetType;

      // target position
      MEMUtils.MemSet(pbyBuffer := ADR(aRobotMoveAxisAbsolute[i].TargetPosition), byValue :=  0, dwSize :=  SIZEOF(aRobotMoveAxisAbsolute[i].TargetPosition));
      IF stPosTable.stEntry[stIO.nLoadIndex].bTargetType THEN
        // as TCP position
        MEMUtils.MemCpy(pbyDest := ADR(aRobotMoveAxisAbsolute[i].TargetPosition.TCPPosition.TCPPosition), pbySrc :=  ADR(stPosTable.stEntry[stIO.nLoadIndex].aPosition), dwSize :=  SIZEOF(stPosTable.stEntry[stIO.nLoadIndex].aPosition));

        // activate the reference position for the S-axis by setting a value unequal to 0 degree
        // this will prevent the robot trying to move past the S-axis limit
        aRobotMoveAxisAbsolute[i].TargetPosition.TCPPosition.Closure.ReferencePosition[0] := 0.1;
        aRobotMoveAxisAbsolute[i].TargetPosition.TCPPosition.Closure.ReferencePosition[4] := - 0.1;

      ELSE
        // as axis positions
        MEMUtils.MemCpy(pbyDest := ADR(aRobotMoveAxisAbsolute[i].TargetPosition.AxisPosition), pbySrc :=  ADR(stPosTable.stEntry[stIO.nLoadIndex].aPosition), dwSize :=  SIZEOF(stPosTable.stEntry[stIO.nLoadIndex].aPosition));
      END_IF;

      // blending between motions
      // BdG Sub interface
      // IF (stPosTable.stEntry[stIO.nLoadIndex].nActionID > 0) AND (stPosTable.stEntry[stIO.nLoadIndex].nActionID < 50) THEN
      // BdG only for gripper
      IF (stPosTable.stEntry[stIO.nLoadIndex].nActionID = 2) OR (stPosTable.stEntry[stIO.nLoadIndex].nActionID = 3) THEN
        // IF (stPosTable.stEntry[stIO.nLoadIndex].nActionID <> 0) THEN
        // use exact stop position for action at standstill
        aRobotMoveAxisAbsolute[i].BlendFactor := 0;
      ELSE
        aRobotMoveAxisAbsolute[i].BlendFactor := SINT_TO_DINT(stPosTable.stEntry[stIO.nLoadIndex].nBlendFactor);
      END_IF;

      aRobotMoveAxisAbsolute[i].BlendType := 0;

      IF (stIO.fSpeedManipulation = 0) THEN
        aRobotMoveAxisAbsolute[i].Speed := stPosTable.stEntry[stIO.nLoadIndex].fSpeed;
      ELSE
        aRobotMoveAxisAbsolute[i].Speed := stPosTable.stEntry[stIO.nLoadIndex].fSpeed * (stIO.fSpeedManipulation / 100);
      END_IF;
      aRobotMoveAxisAbsolute[i].Acceleration := SINT_TO_REAL(stPosTable.stEntry[stIO.nLoadIndex].nAcc);
      aRobotMoveAxisAbsolute[i].Deceleration := SINT_TO_REAL(stPosTable.stEntry[stIO.nLoadIndex].nDec);
    END_IF;

    // -----------------------------------------------------------------------------
    // mapping SetUserFrame FB's
    // -----------------------------------------------------------------------------
    aRobotSetUserFrame[i].RobotNumber := stIO.nRobotNumber;
    nUserFrameNr := SINT_TO_DINT(stPosTable.stEntry[stIO.nLoadIndex].nUserFrameNumber);
    aRobotSetUserFrame[i].UserFrameNumber := nUserFrameNr;
    aRobotSetUserFrame[i].UserFrameData.CoordFrame := stUserFrames.aFrames[nUserFrameNr].aVector;

    // change user frame; if the user frame number differs from the previous stEntry a MLxRobotSetUserFrame will be triggered just before the move
    aChangeUserFrame[i] := bFirstMove OR (nUserFrameNr <> INT_TO_DINT(stMLX.Robot[stIO.nRobotNumber].ActiveUserFrameNumber));

    // -----------------------------------------------------------------------------
    // mapping ToolSelect FB's
    // -----------------------------------------------------------------------------
    aRobotSelectTool[i].RobotNumber := stIO.nRobotNumber;
    nToolNr := SINT_TO_DINT(stPosTable.stEntry[stIO.nLoadIndex].nToolNumber);
    aRobotSelectTool[i].ToolNumber := nToolNr;
    aRobotSelectTool[i].ToolData := stTools.aTools[nToolNr];

    // change (select) tool; if the tool number differs from the previous stEntry a MLxRobotSelectTool will be triggered just before the move
    aChangeTool[i] := bFirstMove OR (nToolNr <> INT_TO_DINT(stMLX.Robot[stIO.nRobotNumber].ActiveToolNumber));
    bFirstMove := FALSE;
  END_IF;
END_FOR;

// map Enable signals to move FB's
FOR i := 0 TO QAmax DO
  aRobotMoveAxisAbsolute[i].Enable := aEnable[i] AND NOT (aUseMoveType[i] = 1) AND (NOT aChangeUserFrame[i] OR (aRobotSetUserFrame[i].Sts_EN AND aRobotSetUserFrame[i].Sts_DN AND NOT aRobotSetUserFrame[i].Sts_ER));
  aRobotMoveLinearAbsolute[i].Enable := aEnable[i] AND (aUseMoveType[i] = 1) AND (NOT aChangeUserFrame[i] OR (aRobotSetUserFrame[i].Sts_EN AND aRobotSetUserFrame[i].Sts_DN AND NOT aRobotSetUserFrame[i].Sts_ER));
  aRobotSetUserFrame[i].Enable := aEnable[i] AND aChangeUserFrame[i];
  aRobotSelectTool[i].Enable := aEnable[i] AND aChangeTool[i];
END_FOR;

// -----------------------------------------------------------------------------
// FB calls (order is important!)
// -----------------------------------------------------------------------------
aRobotSelectTool[0](MLX := stMLX);
aRobotSelectTool[1](MLX := stMLX);
aRobotSelectTool[2](MLX := stMLX);
aRobotSetUserFrame[0](MLX := stMLX);
aRobotSetUserFrame[1](MLX := stMLX);
aRobotSetUserFrame[2](MLX := stMLX);
aRobotMoveAxisAbsolute[0](MLX := stMLX);
aRobotMoveAxisAbsolute[1](MLX := stMLX);
aRobotMoveAxisAbsolute[2](MLX := stMLX);
aRobotMoveLinearAbsolute[0](MLX := stMLX);
aRobotMoveLinearAbsolute[1](MLX := stMLX);
aRobotMoveLinearAbsolute[2](MLX := stMLX);

// -----------------------------------------------------------------------------
// map status signals from move FB's
// -----------------------------------------------------------------------------
FOR i := 0 TO QAmax DO
  IF aUseMoveType[i] = 1 THEN
    aMoveCmd[i].bSts_EN := aRobotMoveLinearAbsolute[i].Sts_EN;
    aMoveCmd[i].bSts_DN := aRobotMoveLinearAbsolute[i].Sts_DN;
    aMoveCmd[i].bSts_IP := aRobotMoveLinearAbsolute[i].Sts_IP;
    aMoveCmd[i].bSts_AC := aRobotMoveLinearAbsolute[i].Sts_AC;
    aMoveCmd[i].bSts_PC := aRobotMoveLinearAbsolute[i].Sts_PC;
    aMoveCmd[i].bSts_ER := aRobotMoveLinearAbsolute[i].Sts_ER;
    aMoveCmd[i].nPercentComplete := aRobotMoveLinearAbsolute[i].PercentComplete;
  ELSE
    aMoveCmd[i].bSts_EN := aRobotMoveAxisAbsolute[i].Sts_EN;
    aMoveCmd[i].bSts_DN := aRobotMoveAxisAbsolute[i].Sts_DN;
    aMoveCmd[i].bSts_IP := aRobotMoveAxisAbsolute[i].Sts_IP;
    aMoveCmd[i].bSts_AC := aRobotMoveAxisAbsolute[i].Sts_AC;
    aMoveCmd[i].bSts_PC := aRobotMoveAxisAbsolute[i].Sts_PC;
    aMoveCmd[i].bSts_ER := aRobotMoveAxisAbsolute[i].Sts_ER;
    aMoveCmd[i].nPercentComplete := aRobotMoveAxisAbsolute[i].PercentComplete;
  END_IF;
END_FOR;

// -----------------------------------------------------------------------------
// map nPercentComplete
// -----------------------------------------------------------------------------
CASE stIO.nSmPosTable OF
  11:
    stIO.nPercentComplete := aMoveCmd[0].nPercentComplete;

  12:
    stIO.nPercentComplete := aMoveCmd[1].nPercentComplete;

  13:
    stIO.nPercentComplete := aMoveCmd[2].nPercentComplete;
  ELSE
    stIO.nPercentComplete := 0;
END_CASE;

// -----------------------------------------------------------------------------
// PosTable status
// -----------------------------------------------------------------------------
stIO.bWaitForExecute := bWaiting;
stIO.bDone := (stIO.nSmPosTable = 40);
stIO.bIdle := (stIO.nSmPosTable < 11);
stIO.bBusy := (stIO.nSmPosTable >= 11 AND stIO.nSmPosTable < 40);
stIO.bStopping := bStopRequest;
bError := stMLX.JoggingMode;
FOR i := 0 TO QAmax DO
  bError := bError OR (aMoveCmd[i].bSts_EN AND aMoveCmd[i].bSts_ER)
        OR (aRobotSelectTool[i].Sts_EN AND aRobotSelectTool[i].Sts_ER)
        OR (aRobotSetUserFrame[i].Sts_EN AND aRobotSetUserFrame[i].Sts_ER);
END_FOR
IF bError THEN
  stIO.nErrorCode := 1000 + stIO.nSmPosTable;
  stIO.nSmPosTable := 99;
END_IF
